require "logger"

#-------------------------------------------------
# Module to allow class-specific logging to be
#  mixed-in to other classes
#-------------------------------------------------
#
module MyLog
	@name4log = self.class.name
	def log_debug(msg) @log.debug(@name4log) { msg }	end
	def log_info(msg)  @log.info(@name4log)  { msg }	end
	def log_warn(msg)  @log.warn(@name4log)  { msg }	end
	def log_error(msg) @log.error(@name4log) { msg }	end
	def log_fatal(msg) @log.fatal(@name4log) { msg }	end
end

# ------------------------------------------------
# A directory that holds a collection of
# Nagios archive log files
# ------------------------------------------------
#
class NagArchLogDir

	include MyLog
	attr_reader :dirname

	def initialize( d, logger = nil )

		# Set up logging for this instance
		@log = logger.class == Logger ? logger : Logger.new(STDOUT)

		# Validate parameter
		@dirname = File.expand_path(d)
		raise "Import directory not found, #{@dirname}" unless File.directory?(@dirname)

		log_info "Archive directory, #@dirname"

		raise "Permission problem. Directory #{@dirname} is not writable" unless File.writable?(@dirname)

		# Initialise containers
		@alllogs = Array.new		
		@newlogs = Hash.new		
		@cache = NagArchLogCache.new("archlogs.cache.txt",@dirname)
		
		# Compile a list of new log files
		#
		Dir.new(@dirname).entries.each do |fn|
			fullname = File.join(@dirname,fn)
			# Only handle regular files with *.log extension
			next unless File.file?(fullname) and File.extname(fullname) == ".log"
			@alllogs << fn
			# Check the cache for previously processed files
			@newlogs[filekey(fn)] = fn unless @cache.has_entry?(fn)
		 end
		
		log_info "Valid logfiles found: #{@newlogs.keys.size}"

		# Clear redundant entries from cache
		@cache.each { |fn| @cache.remove_entry(fn) unless @alllogs.include?(fn) }

	end

	def count
		@newlogs.keys.size
	end

	def each
		# Return each logfile as a full pathname
		@newlogs.keys.sort.each { |fk| yield File.join(@dirname,@newlogs[fk]) }
	end

	def processed(filename)
		fn = File.basename(filename)
		@newlogs.delete(filekey(fn))
		@cache.add_entry(fn)
	end

 private

	def filekey(fn)
		if fn =~ /(\w+)\-(\d{2})\-(\d{2})\-(\d{4})\-(\d{2})\.log/ 
			$4 + $2 + $3 + "." + $5 + "." + $1
		 else	 
			fn
		 end
	end
 
end

# ------------------------------------------------
# A cache file that holds a list of filenames that
# have already been processed from this directory
# ------------------------------------------------
#
class NagArchLogCache

	def initialize(cachefile,cachedir)

		@fullname = File.expand_path(cachefile,cachedir)
		@filename = File.basename(@fullname)
		@dirname  = File.dirname(@fullname)

		@contents = Array.new

		# Check if file exists, create if not
		if File.exists?(@fullname)
			raise "Cache file '#@filename' is not a regular file" unless File.file?(@fullname)
			raise "Cache file '#@filename' is not writable" unless File.writable?(@fullname)
			read_cache
		 else
			write_cache 
		 end

	end

 	def each
 		@contents.each { |fn| yield fn }
	end

 	def has_entry?(fn)
 		@contents.include?(fn)
	end

 	def add_entry(fn)
 		@contents << fn
		write_cache
	end

 	def remove_entry(fn)
 		@contents.delete(fn)
		write_cache
	end

 	def dump_cache
 		puts "Cache contents"
 		@contents.each { |fn| puts "\t#{fn}"}
	end

 private
 
 	def read_cache
 		File.open(@fullname) do |f|
 			f.each do |line|
 				# Skip blank lines and comments
 				next if line =~ /^\s*$/ or line =~ /^\s*#/
 				next unless line =~ /^\s*(\w[\w\.\-]+)/
 				@contents << $1
			end
		end
	end

 	def write_cache
 		File.open(@fullname,"w") do |f|
			f.puts <<HDR
#---------------------------------------------------------------------
# This is the cache file for the Nagios log file reader.
# It holds a list of the files in the current directory that have
# already been processed by the script.
#
# The file is created and maintaned by the script.
#
#---------------------------------------------------------------------
# 		DO NOT EDIT THIS FILE BY HAND
#---------------------------------------------------------------------
HDR
 			@contents.each { |fn| f.puts fn }
		 end
	end

end
